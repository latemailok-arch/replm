"""One-time helper: download TREC coarse questions and write trec_data.py.

Source: CogComp/trec (Li & Roth 2002). Raw label files hosted by UPenn.
Run once during development, commit the generated trec_data.py.

Usage:
    python -m benchmarks.oolong.fetch_trec
"""

from __future__ import annotations

import urllib.request
from pathlib import Path

# Raw label files from UPenn (same source as CogComp/trec on HuggingFace).
_URLS: dict[str, str] = {
    "train": "https://cogcomp.seas.upenn.edu/Data/QA/QC/train_5500.label",
    "test": "https://cogcomp.seas.upenn.edu/Data/QA/QC/TREC_10.label",
}

# TREC coarse label prefixes → paper category names (Bertsch et al 2025).
_LABEL_MAP: dict[str, str] = {
    "ABBR": "abbreviation",
    "ENTY": "entity",
    "DESC": "description",
    "HUM": "human_being",
    "LOC": "location",
    "NUM": "numeric_value",
}


def _fetch_and_parse(url: str) -> list[tuple[str, str]]:
    """Download a TREC label file and parse into (text, category) pairs.

    File format: ``COARSE:fine question text here`` — one per line.
    """
    req = urllib.request.Request(url)
    with urllib.request.urlopen(req, timeout=30) as resp:
        raw = resp.read()

    questions: list[tuple[str, str]] = []
    for line in raw.splitlines():
        # One known non-ASCII byte (\xf0) in the dataset; replace with space.
        decoded = line.replace(b"\xf0", b" ").strip().decode("utf-8", errors="replace")
        if not decoded:
            continue

        # Format: "COARSE:fine question text"
        fine_label, _, text = decoded.partition(" ")
        coarse = fine_label.split(":")[0]

        if coarse not in _LABEL_MAP:
            print(f"  Skipping unknown label: {coarse!r}")
            continue

        text = text.strip()
        if not text:
            continue

        questions.append((text, _LABEL_MAP[coarse]))

    return questions


def _write_module(questions: list[tuple[str, str]], out_path: Path) -> None:
    """Write trec_data.py as a Python literal."""
    counts: dict[str, int] = {}
    for _, label in questions:
        counts[label] = counts.get(label, 0) + 1

    counts_str = ", ".join(f"{k}: {v}" for k, v in sorted(counts.items()))

    lines: list[str] = []
    lines.append('"""TREC coarse questions bundled from CogComp/trec (Li & Roth 2002).')
    lines.append("")
    lines.append(f"Total: {len(questions)} questions ({counts_str}).")
    lines.append("")
    lines.append("Generated by fetch_trec.py — do not edit manually.")
    lines.append('"""')
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("from dataclasses import dataclass")
    lines.append("")
    lines.append("")
    lines.append("@dataclass(frozen=True)")
    lines.append("class TrecQuestion:")
    lines.append("    text: str")
    lines.append("    label: str")
    lines.append("")
    lines.append("")
    lines.append("CATEGORIES: list[str] = [")
    for cat in sorted(_LABEL_MAP.values()):
        lines.append(f'    "{cat}",')
    lines.append("]")
    lines.append("")
    lines.append("")
    lines.append("TREC_QUESTIONS: list[TrecQuestion] = [")

    for text, label in questions:
        escaped = text.replace("\\", "\\\\").replace('"', '\\"')
        lines.append(f'    TrecQuestion("{escaped}", "{label}"),')

    lines.append("]")
    lines.append("")
    lines.append(f"assert len(TREC_QUESTIONS) == {len(questions)}")
    lines.append("assert all(q.label in CATEGORIES for q in TREC_QUESTIONS)")
    lines.append("")

    out_path.write_text("\n".join(lines))
    print(f"Wrote {out_path} ({len(questions)} questions)")


def main() -> None:
    all_questions: list[tuple[str, str]] = []

    for split, url in _URLS.items():
        print(f"Fetching {split} split...")
        questions = _fetch_and_parse(url)
        print(f"  Got {len(questions)} questions")
        all_questions.extend(questions)

    print(f"\nTotal: {len(all_questions)} questions")

    out_path = Path(__file__).parent / "trec_data.py"
    _write_module(all_questions, out_path)


if __name__ == "__main__":
    main()
